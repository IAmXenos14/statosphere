# All of these fields are optional, as is this file itself,
#   in which case these values can be managed in the UI.

# The name of the stage.
project_name: "Statosphere"

tagline: "Give your bots variables and launch them into...the Stat-O-Sphere! (phere) (ere)"

creator_notes: "
This is a stage for creating custom variables and rules for stat-tracking or behavior implementation. 
_Up front, this is pretty experimental, and I'm continuing to play with and expand upon it, so it could be unstable._ 
But it could also be fun to play with as-is. If you can't read all of the notes below, please refresh this page until the \"Show More\" prompt renders.
<br>
<br>
The stage is comprised of three core, configurable elements:<br>
<ul>
<li>Variable definitions with per-turn, post-input, and post-response assignment options
<li>Function definitions for creating re-usable logic
<li>Zero-shot classification rules to use inference on inputs and responses and apply updates to variables as a result
<li>Content modification rules which alter input, response, system messages (post-response details), and stage directions (additional LLM instruction) based on specified conditions
</ul>
<br>
**Example Applications**<br>
This stage has no default configuration and will do nothing on its own. However, through configuration, a wide variety of effects are possible:<br>
<ul>
<li>Stat tracking and display: use inference to roughly gauge changes present in the input or response and translate that into a number to apply to variables
<li>Scenario escalation tracking: use perTurnUpdate to increase a turn variable, then add prompt rules to feed updated scenario data as time marches on--go crazy and use inference to adjust the pace of escalation
<li>Rule or behavior reinforcement: apply classifiers or keywords to remind the LLM of your bot's quirks when the user's input should trigger them
<li>Dynamic response guidance: use inference to detect the nature of the user's input and ask the bot to focus its writing in different ways
<li>Input clean-up: use regex to strip bracketed LLM instruction from the user's input and embed it into stage directions so it doesn't appear in the chat and is only included in the current prompt
<li>Probably all kinds of other creative, insane applications
</ul>
<br>
<br>
**Configuration**<br>
The stage has three fields that define the elements above; these are provided as JSON objects because Chub's stage configuration UI is not yet prepared for something so elaborate. 
Don't worry! You don't have to hand-build JSON to paste in here: I made [an external tool](https://lord-raven.github.io/statosphere-editor/) 
that will produce JSON that you can copy and paste into the stage's configuration. You can also paste configuration from your bot into the tool to make modifications.
<br>
<br>
There is a lot of information that I will need to cover here, but I have not had time to do so yet. For the moment, please see my example bots and the configuration of the stage on those bots; 
you can view this by starting a chat with one and looking at the active stages in the chat settings. 
<br>
<br>
**Order of Operations**<br>
For reference, the rules on this stage are applied in this order:<br>
<ul>
<li>User submits input
<ul>
<li>Per-turn variable operations are performed, in the order that variables are defined
<li>Classifiers with an input hypothesis are applied to the input, in the order that classifiers are defined
<li>Post-input variable operations are performed, in the order that variables are defined
<li>Input content modifications are executed, in the order that these modifications are defined
<li>Stage direction modifications are executed, in the order that these modifications are defined
</ul>
<li>Bot returns response
<ul>
<li>Classifiers with a response hypothesis are applied to the response, in the order that classifiers are defined
<li>Post-response variable operations are performed, in the order that variables are defined
<li>Response content modifications are executed, in the order that these modifications are defined
<li>System message modifications are executed, in the order that these modifications are defined
</ul>
</ul>
<br>
<br>
**Inference Details**<br>
This stage makes API calls to a Hugging Face backend that I have set up to leverage a zero-shot classification model. 
If this backend is unavailable or some other error occurs in calling it, the stage will swap to applying a very small, local, zero-shot model. 
Chub's stage timeout is pretty short and that can cause the stage to make a second call or give up entirely if these inferences take too long. 
This is hopefully something that will be more addressable in the future.
"

# 'PUBLIC', 'PRIVATE', or 'UNLISTED'.
visibility: 'UNLISTED'

# 'ADJACENT' | 'NONE' | 'COVER' | 'FULLSCREEN'
# 'ADJACENT' is default. The frame will display on the side of the
#   chat on desktop and above/in the top half of the chat on mobile.
# 'NONE' will not display, only run.
# 'COVER' will, indeed, cover the chat history completely,
#   but leave the text input box.
# 'FULLSCREEN' will make nothing below the header bar
#   show except for your stage.
position: 'NONE'

# Self-explanatory.
tags:
 - 'Stage'
 - 'Utility'
 - 'Stats'

# The schema of any user-supplied config.
# If your stage requires a configuration but has no
#   defined schema, it won't work.
# source: input/response/both
config_schema:
  title: Statosphere Settings
  type: object
  properties:
    configJson:
      title: Configuration
      description: Use <a href="https://lord-raven.github.io/statosphere-editor/">the Statosphere editor</a> to build configuration JSON to paste here--or paste this into the editor to populate the form and make changes.
      type: string
      value: >
        {}
    debugMode:
      title: Debug Mode
      description: Leave disabled unless you don't care about stability.
      type: boolean
      value: false

# The schema of the state that you store.
# This isn't needed even if you do store state,
#   and is here more for future use cases to
#   optimize storage.
state_schema:
  init:
    type: object
    properties:
      grid:
        type: string
  message:
    type: object
    properties:
      angry:
        type: boolean
        default: true
  chat:
    type: object
    properties:
      visited:
        type: array
        items:
          type: integer

# Whether to publish as 'Anonymous' instead of under your username.
# is_anonymous: false

# Self-explanatory.
# ratings_disabled: false

# This is here for future cases where ex. you need user secrets,
#    but currently does nothing.
# permissions:

# extension_id is automatically generated on push with a new project;
#    you should not make or set this value.
# github_path will be added if it does not exist. It is the URL of the repo.


github_path: 'https://github.com/Lord-Raven/statosphere'


extension_id: 'statosphere-3704059fdd7e'

